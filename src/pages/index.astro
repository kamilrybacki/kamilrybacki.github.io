---
import SVG from '@components/StyledSVG.astro';
import BasicPageLayout from '@layouts/BasicPageLayout.astro';
import SplashDecoration from '@components/SplashDecoration';
import Menu from '@components/Menu';
import { theme } from '@root/tailwind.config';

import '@styles/glitch.css';

const indexOptions = [
  {
    name: 'Projects',
    link: '/projects',
    style: 'text-accent text-7xl'
  },
  {
    name: 'Blog',
    link: '/about',
    style: ''
  },
  {
    name: 'Contact',
    link: '/contact',
    style: ''
  }
];
---
<style>
  @keyframes dash {
    to {
      stroke-dashoffset: 0;
    }
  }
</style>
<script define:vars={{indexOptions, theme}}>
  const fontsMap = {
    'Projects': 'font-code',
    'Blog': 'font-handwriting',
    'Contact': 'font-display'
  }

  function getOffset(element) {
    const rect = element.getBoundingClientRect();
    return {
      x: rect.left + window.scrollX + rect.width / 2,
      y: rect.top + window.scrollY + rect.height / 2,
    };
  }

  const drawLinesPathFromPoints = (steps, color, size, dash) => {
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

    const curve = steps.reduce((currentCurve, displacements) => {
      if (currentCurve.length === 0) {
        return `M ${displacements.x} ${displacements.y} `;
      }
      return currentCurve + `L ${displacements.x} ${displacements.y} `;
    }, '');

    path.setAttribute('d', curve);
    path.setAttribute('fill', 'transparent');
    path.setAttribute('stroke', color);
    path.setAttribute('stroke-width', size);

    path.classList.add('h-fit');

    path.style.strokeDasharray = path.getTotalLength();
    path.style.strokeDashoffset = path.getTotalLength();

    dash && path.setAttribute('stroke-dasharray', dash);
    return path;
  }

  document.addEventListener('DOMContentLoaded', () => {
    const menuElement = document.getElementById('index-menu');
    const glitchTextElement = document.getElementById('glitch-text');
    const listElements = [...menuElement.getElementsByTagName('li')];

    const createPathsSVG = () => {
      const svgID = `path-${menuElement.id}`;
      const pathsSVG = document.getElementById(svgID) 
        ? document.getElementById(svgID)
        : document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      pathsSVG.childNodes && pathsSVG.childNodes.forEach((child) => {
        child.remove();
      })
      pathsSVG.setAttribute('version', '1.1');
      pathsSVG.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      pathsSVG.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
      pathsSVG.setAttribute('id', svgID)

      pathsSVG.setAttribute('width', window.innerWidth);
      pathsSVG.setAttribute('height', window.innerHeight);

      pathsSVG.classList.add('fixed', 'z-1', 'top-0', 'left-0', 'w-full', 'h-full', 'pointer-events-none');
      menuElement.appendChild(pathsSVG);

      const targetPosition = getOffset(glitchTextElement);
      const menuElementCenter = getOffset(menuElement);

      const gap = Math.abs(targetPosition.x - menuElementCenter.x);

      listElements.forEach((listElement) => {
        const linkElement = listElement.getElementsByTagName('a')[0];
        const elementCenter = getOffset(linkElement);

        const pathStart = {
          x: elementCenter.x,
          y: elementCenter.y + linkElement.offsetHeight / 3.5,
        }
        const pathEnd = {
          x: targetPosition.x,
          y: targetPosition.y + glitchTextElement.offsetHeight / 2,
        }

        const pathData = [
          pathStart,
          {
            x: pathStart.x,
            y: pathEnd.y + gap / 2,
          },
          {
            x: pathEnd.x,
            y: pathEnd.y + gap / 2,
          },
          {
            x: pathEnd.x,
            y: pathEnd.y + gap / 3,
          }
        ];
        const path = drawLinesPathFromPoints(pathData, theme.colors.glow, 1, 1);
        path.classList.add('stroke-current', 'stroke-linecap-round', 'stroke-linejoin-round');
        path.id = `path-${listElement.id}`;
        pathsSVG.appendChild(path);
      });
    }

    const pathVelocity = 0.75;  // px/ms

    const previousResizeListener = window.onresize;
    document.addEventListener('resize', () => {
      previousResizeListener && previousResizeListener();
      createPathsSVG();
    })
    createPathsSVG();
    listElements.forEach(element => {
      const matchingPath = document.getElementById(`path-${element.id}`);
      const animationTime = matchingPath.getTotalLength() / pathVelocity;
      element.onmouseenter = () => {
        matchingPath.style.animation = `dash ${animationTime}ms ease-in-out forwards`;
      };
      element.onmouseleave = () => {
        matchingPath.style.animation = "none";
      };
    })
  }); 
</script>

<BasicPageLayout 
  title="Kamil Rybacki"
  style="flex flex-col justify-center items-center overflow-hidden"
>
  <div class="flex flex-row justify-around items-center my-auto w-full">
    <div class="w-fit ml-auto flex flex-col items-end z-1" id="menu-wrapper">
      <div class="flex flex-row mr-auto">
        <div class="relative flex justify-center w-32 text-accent ml-3">
          <SVG src="images/logo" alt="Logo"/>
        </div>
        <h1 class="relative top-9 text-7xl font-display font-[700]">
          amil Rybacki
        </h1>
      </div>
      <div class="border-[1px] border-accent my-4 w-[105%] opacity-50"/>
      <h2 class="relative flex flex-row items-center text-4xl mt-2 ml-3 font-body font-[700] text-glow gap-3">
        <span class="my-auto">
          Figuring out
        </span>
        <span
          class="hero glitch layers deform text-4xl tracking-widest my-auto"
          data-text="undefineds"
          id="glitch-text"
        >
          undefineds
      </span>
      </h2>
      <Menu
        options={indexOptions}
        style='relative flex flex-row-reverse gap-6 text-5xl font-bold mt-20 items-center justify-center'
        globalListStyle="relative bg-background my-auto z-99"
        id="index-menu"
      />
    </div>
    <SplashDecoration/>
  </div>
</BasicPageLayout>
