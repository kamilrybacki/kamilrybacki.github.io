---
title: "Sow with words, reap with interactivity"
date: "2023-09-27"
description: "An article about enhancing softdev-oriented blog posts with interactive widgets."
tags: ["astro", "codepen", "jupyter", "jupyterlite"]
image:
  thumbnail: "components"
  hero: "components"
  alt: "Interacting with code"
---

## Weirdly overarching introduction

A portion of useful knowledge that finds the right pitcher along the way can often be forged into action
that pushes new boundaries or, at least, helps keep everything in order by informed maintenance.

Sounds very pompous, but the main trick here is that good ideas become really, useful ones
only if they are shared effectively universally and understandably. You need to sell them,
so other people can find new, exciting angles of utilizing them and keep the ball rolling.

Given that I like to ponder about hypothetical and abstract scenarios that I hope prove my points,
let's imagine the chaotic times of prehistoric cavemen, still polishing out novel concepts like
not getting obliterated by a mammoth or any notion of technology.

### A case of a rolling stone

Suppose that one of them has found something rather interesting. When he picks up a very angular, edgy rock
and tries to roll it on the ground, it stops noticeably faster than a round rock would. He fiddles with small pebbles,
medium-sized chunks and even some heavy chonkers, but the result is always the same. So, the shape is the key.
Round good, edgy bad - one of the first marvels of empirical research method is born and the gears begin to turn.
The caveman quickly smashes one rock with another to make it round and after some iterations, he manages to
create humanity's first wheel.

Now, the question is - how does he share this knowledge with his fellow cavemen? He can't just tell them
about it, because they don't have a word for `wheel` yet - it has just been invented. So,
he decides to just roll it around and hope that they will notice. And they do. They see our caveman
with his new invention and they are intrigued. They want to know more. So, they ask him about it,
but he just points at the wheel and encourages them to try it out. They do and they are amazed.
Then, they take that wheel and duplicate it. After some time and more experimentation, they found out
that it is possible to attach it to a cart and use it to transport heavy objects.

By presenting one idea and letting others play around with it in a safe environment, a whole new
world of possibilities can be opened. And that's the main point of this article.
Ideas and knowledge must be spread around, experimented upon and "roll" freely to gain momentum and become useful.
Those that are delegated to shelves or boring PowerPoint presentations are doomed to be overgrown by moss. And that's
a shame because they could have been used to build something great 😞.

### From cavemen to software engineers

So, what out rock-bashing friends have in common with people who dabble with code in the 21st century?

Let's start with the fact that, well, they are human 🤷. Their understanding can be supercharged by the same
mechanisms of messing around with, now more sophisticated, sticks and stones. A good presentation of even more
abstract concepts can make wonders and that is coming from a person who, for two years, sold the classic shtick
about electrical current being water flowing through pipes to elementary school kids. It works 👨‍🏫. You don't even
have to sell the whole truth, just a good enough approximation that can be used to build upon.

There is no water in our outlets, electrons and protons don't "dislike" each other and the fact that there
is no strict typing in Python 🐍 doesn't speed up things in large or medium-sized, enterprise(ish) projects.
But, those concepts are good enough to get the ball rolling i.e. hype up somebody about
a new idea by making them feel able to understand it. Fires up 🏎️ their hunger for more [knowledge] 🧠.

That is somewhat connected to the effect of "tutorial hell", where people constantly watch more and more
sketchy tutorials, but never actually build anything. They are stuck in a loop of consuming information
with no way of trying it out, even for a quick second. This leaves out one of the strong mechanisms of learning:
muscle memory through repetition. Getting it down through trying.

For example, if somebody actively programs in C (or C++) 💀, they will start to,
seemingly automatically, put semicolons around their code without even thinking about it.
It's a reflex, a weird convolution built between the act of punching the semicolon key
and acknowledgment that a block of code (e.g. a line) has been finished.

I am not saying that broadening the theoretical knowledge is of no use because there is a plethora
of fields of science where there is no experimentation at all and You just diddle around with exotic thoughts 24/7.
But, in the case of technical fields like software engineering, a couple of falls from the bike 🚲 must be made.
The trick is to create an isolated, safe environment where You can execute some awful, dirty JavaScript snippets.

Also, the second common ground with our saber-tooth dodging ancestors is that if You start to learn a new language
(or programming at all), You sometimes feel like a caveman in Plato's cave who tries to come to the real
truth through walls of documentation 🗄️🗄️🗄️🗄️️. And this sucks, let's do something about it.

### Independency injection - widgets to let the beeps go boop

In the spirit of this weird mix of evolutionary and pedagogical lines of thought, I've decided to implement
a couple of ways for my readers to interact with the technical concepts I want to present in my blog posts.
Those topics are always inherently related to communication between humans and machines, so it makes sense
to let the reader play around with the code and see how it behaves in real-time. In some cases, it may also 
be useful to show some results or data, so that was also the aspect I wanted to touch upon.

Before tackling this problem, I've set up a couple of requirements that my solutions must meet:

1. Any widgets implemented must be customizable and responsive in terms of their styling.
As You can see, I went for a more blackboard/notebook look on my site this time, so
at least I want to be able to change the colors of the new components to match the overall theme. 🎨
2. Any component that requires more extensive computations on the client side must be loaded **on demand**,
by the user. I don't want to slow down the initial page load time by loading a bunch of heavy code
because that could make somebody leave my article before delving into it. 🏳️
3. New widgets must easily integrate with my current setup i.e. utilize the MDX syntax. 🧩

When it comes to code bases of any kind I want to highlight, there are three aspects that
I want to be able to cover using the aforementioned toolbox: **organization**, **syntax** and **functionality**.

By **organization**, I mean the ability to show the structure of my code i.e. how it is split into
different files and folders. This is especially useful when I want to show how a certain project
is structured and how it can be navigated. This is also crucial whenever a specific file-based
routing system is used (e.g. Next.js) or the chosen dev tool configuration is done via different files (e.g. Ansible).

By **syntax**, I mean the ability to show how the code is structured on a micro level i.e. how
it is split into different functions, classes, etc. Here I am especially interested in the ability
to use language-specific syntax highlighting, in a way that doesn't require me to manually
implement a plethora of widgets i.e. `PythonSnippet`, `CPlusPlusSnippet` ("PlusPlus", yuck 🤮) and so on.
Also, an ability to add comments in a way that doesn't require me to manually add them to the code
would be cool since it keeps the juicy parts lean and adds some sort of *call to action* thingy, that
encourages the reader to interact with the code.

And last but not least, **functionality**. Here I want to be able to show how the code behaves, so
the target tool must be able to execute it and show results to the user in a readable manner.
Also, let's be real, it is cool to be able to run e.g. Python or Rust 🦀 in the browser,
without any additional setup on the user side, like some weird Google Chrome extension.
I also want to be able to easily prepare any data that I want to show in a table or a chart,
that supplements the code snippet **and** set up package dependencies for the code to run,
without any hassle for the reader.

Here, I guess, You can also see one common thread - **don't bother the reader too much**.
The resulting widgets must work *automagically* 🪄, with mystical fairies moving around
the bytes from one pointer to another in the background 🧚🧮.

In terms of **results presentation**, I want to show cool-looking, readable charts and tables.
That's it 🎉. Let's get to work. From now on, the article will get more technical, so *hang in there* 🐈.

## Whaddaya buyin' - whaddama sellin'?

### Code organization - `FileTree` component

So, to kick off this section, a rather simple, but useful component - `FileTree`. It is a simple
tree-like structure that shows the structure of a given directory. It is implemented manually,
without any external libraries as an Astro component.

<FileTree
  root="src/"
  tree={[
    {
      "components/": [
        {
          "markdown/": [
            "CodePenEmbed.astro",
            "FileTree.astro",
            "CodeSnippet.astro",
            "CurseWord.astro",
            "JupyterLiteEmbed.tsx",
            "ScribbleGraph.tsx"
          ]
        },
        "..."
      ]
    },
    "..."
  ]}
  annotations={`
    src/components:Here is the components directory of my site.
    FileTree.astro:Hey look! It's this component!
  `}
  links={`
    FileTree.astro:https://raw.githubusercontent.com/kamilrybacki/kamilrybacki.github.io/main/src/components/markdown/FileTree.astro
    components:https://github.com/kamilrybacki/kamilrybacki.github.io/tree/main/src/components
  `}
/>

As You can see, besides looking like a modified `tree` command output, it also allows me to add
annotations and links to specific files. Visually, it somewhat emulates the look of a macOS window,
with the theming consistent with the rest of the site. From a technical point of view,
it is a simple component that takes a couple of props: 

- the name of the root directory
- a tree-like structure that describes the directory structure (basically a JS object)
- a string that contains annotations for specific files
- a string that contains links for specific files

To properly render the tree, I've used a recursive function that takes a tree-like structure
and renders it so that directories are rendered as `ol` elements and files as `li` elements.
So, in simple terms, a Depth First Search (DFS) 🌳🔍 algorithm is used to traverse the tree:
if an element is a directory, the function is called recursively with the current element
as the root of the tree (in the file [source] it is a function called `traverseTreeBranch`).
Each entry is also checked against the annotations links list so additional HTML markup
with CSS styling can be added if needed (e.g. to create external links).

In the future, I want to extend this component to allow for the rendering of GitHub repositories
with optional linking to individual files. This should be doable by using [GitHub Octokit] 
(which has a dope [logo], btw 💯) to hit appropriate API endpoints and fetch target repo information.

### Code syntax - `CodeSnippet` component

Here, another marvel of CSS hacks and botches is to be presented - `CodeSnippet`. It is a component that
basically mimics another terminal window, but now - it shows code! It is basically a wrapper around
the `Code` component of `astro:components` that allows me to add some additional styling and
introduce extra commenting capabilities, which seemingly blend into the whole `vim`-like aesthetic.

The syntax highlighting is automatically done via `shiki` library under-the-hood, so I don't have to
manually implement a bunch of components for each language I want to highlight. The component takes three obligatory props:

* code in the form of multiline string format
* a string that contains the language of the code e.g. `js` (these tags correspond to the ones that are normally used within Markdown code blocks, so it is slightly easier to copy-paste code from an existing Markdown file)
* a name of the mock file that is being displayed (because remember, we pretend that it is a terminal window with a cool title bar 🙈)

Additionally, single- or multi-line comments can be passed as a prop, so they can be displayed using cute little accents.

So, let's see it in action with some initial Python code:

<CodeSnippet
  code={`
    def bubble_sort(arr):
        # Traverse through all array elements
        for i in range(len(arr)):
            # Last i elements are already in place
            for j in range(0, len(arr) - i - 1):
                # Traverse the array from 0 to n-i-1
                # Swap if the element found is greater
                # than the next element
                if arr[j] > arr[j + 1]:
                    arr[j], arr[j + 1] = arr[j + 1], arr[j]
  `}
  language="py"
  filename="bubble_sort.py"
/>

Here, You can see that the code is highlighted properly, so `shiki` has done its job, but the actual author of the code (good ol' trusty GPT4 🙊) went with the 1:1 ratio of comments to code lines, so it is not that readable. Maybe there is another way to move those comments, leaving our code clean?

<CodeSnippet
  code={`
    def bubble_sort(arr):
        for i in range(len(arr)):
            for j in range(0, len(arr) - i - 1):
                if arr[j] > arr[j + 1]:
                    arr[j], arr[j + 1] = arr[j + 1], arr[j]
  `}
  language="py"
  filename="bubble_sort_clean.py"
  annotations={`
    2:Traverse through all array elements
    3:Last i elements are already in place
    4-5:Swap if the element found is greater than the next element
  `}
/>

Now, if You hover over the lines either decorated with a `!` mark (single-line comment) or enclosed between `{` and `}` decorators (multiline comment), a small tooltip will pop up @ Your mouse position, with the comment in it! In practice, it works mainly for shorter comments, but it is still a nice touch. Each comment is added as an absolution-positioned `div` element, so it is not a part of the code itself and hovers in front of it. Initially, it is hidden, but when the user hovers over the line, it is shown via `EventListener`s added to the line element itself:

<CodeSnippet
  code={`
    const appendCommentTooltip = (lineElement, text, prefix) => {
      if (lineElement.lastChild.getAttribute('role') !== 'tooltip') {
        const annotationOverlay = document.createElement('div');
        annotationOverlay.classList.add(...[
          'absolute', 'flex', 'flex-wrap', 'opacity-0',
        ]);
        annotationOverlay.setAttribute('role', 'tooltip')
        annotationOverlay.innerHTML = \`\${prefix}: \${text}\`
          .split(' ')
          .map((word) => \`<span>\${word} </span>\`)
          .join('');
        lineElement.appendChild(annotationOverlay);
        lineElement.onmouseenter = (e) => ... // Show tooltip;
        lineElement.onfocus = (e) => ... // Show tooltip;
        lineElement.onmousemove = (e) => ... // Move tooltip to mouse position ;
        lineElement.onmouseleave = () => ... // Hide tooltip ;
      };
  `}
  language="js"
  filename="appendCommentTooltip.js"
  annotations={`
    2:If there is already a tooltip present, skip
    4-6:Tailwind, bby 😎
    8-11:Split words into spans for an auto wrap with flex
  `}
/>

Additionally, this cleanup also benefits the copy-and-paste functionality of the widget (the icon visible in the lower right corner), since it will not copy the comments, only the code.

When it comes to theming, a plethora of well-known IDE themes is available, which can be checked out by reading [`shiki` library docs on how to load them] via the library API. As a final touch, the component will automatically prepare the code snippet so it starts at a first, non-empty line and ends with an empty newline at the end. In my case, I am using the GitHub Dark theme. A final touch to the look of this component are line numbers, that are simple `<span>` elements appended to each `line`-class component, generated by `shiki`.

<CodeSnippet
  code={`
    let foundLinesIndex = 1;
    codeLines.forEach((line, index) => {
      const numberSpan = document.createElement('span');
      numberSpan.classList.add(...['text-glow', 'opacity-50']);
      numberSpan.innerText = \`\${foundLinesIndex.toString().padStart(4, ' ')}\`;
      line.insertBefore(
        numberSpan,
        line.firstChild
      );
      if (index === codeLines.length - 1) {
        line.classList.add('opacity-25')
      }
      foundLinesIndex++;
    });
  `}
  language="js"
  filename="lineNumbers.js"
  annotations={`
    2:This list is from DOM query of all '.line' elements
  `}
/>

### Code functionality - two for one 👯

Here we arrive at the *creme de la creme* of this article - the ability to execute code in the browser, without jumping a lot of unnecessary hoops. You click "Run" - it runs. It runs on Your 2021 MacBook M1 Pro, it runs on Your bootleg Android phone from Temu, and it runs on those awful, Windows ME runnin-🍑 computers that still occupy unaccountable laboratories at Your university 🙉 (and are connected to crucial apparatus worth thousands of 💰). **It works on Your machine**.

Here, I've made a small distinction when it comes to how I perceive the functionality of code that I want to present. Both of those subcategories
are concerned with the type of *result* the code has to return. Sounds pretty abstract, but let's compare a code snippet that applies a sorting algorithm to a list of numbers and a code snippet that centers a `<div>` element on the page. 

One of them must be shown in a way, that lets the user follow a specific path along which the input data is being transformed. So, you can say it is more of a *procedural* nature with a clear, linear path of execution i.e. a protocol. Here, You want to highlight each step, say what it does and do a simple "before-after" comparison. This is the case of the sorting algorithm.

The other one is more of a *declarative* nature, where You want to show the result of a specific operation. Here, You don't care about the steps, You just want to see the result. Those cases are mostly connected with design and data visualization topics, where You want to show a specific result of a specific operation. From a practical point of view, there is no notion of steps at all. So, this is the case of the centered `<div>` - CSS is applied to predefined HTML elements, no matter what the input is, it is (mostly) all set in stone. A one-shot operation. Here, showing the correct combination of HTML markup, CSS styling and *maybe* some complimentary JS code is the key.

#### Otherworldly possibilities - `JupyterLiteEmbed` component

This will be a good one. If You've ever encountered topics connected with Python and data science, there is a very good chance You've heard about a thing called Jupyter notebooks. They are a way to share code in an interactive manner, where each computational step is represented by a code cell, which can be executed independently, but still within an overall context of the current program execution.

![Jupyter Notebook real-time modification](/assets/images/jupyter.png)

As You can see, I've changed the state of the `a` variable between two subsequent runs of the second and third code cells, **but** I haven't touched the source in any other places. This resulted in two different prints at the end of this notebook. Speaking more generally, I've modified the **input data**, with **no modifications** to the **protocol**, which is the key here. This is a very powerful concept, that allows for a very quick and interactive way of experimenting with code.

Moreover, that's one of the main reasons why this tool has been widely adopted among data scientists and machine learning engineers. They can try a series of different `csv`s or other external datasets, but still mangle them using the same implementations of statistical methods or machine learning models, while still getting nice visual output along the way to see if everything is going according to plan (e.g. if the data is being properly normalized or how it is correlated).

So cool, I'm sold, and hopefully, You're sold - let's bring this bad boi as an awesome, little embed to this site (and by checking out my source code, You can do it too! 🤸). But wait, I've shown You an example of Python code but browsers don't have any virtual environments built for it. It's only high-octane Javascript pumping through V8 (or SpiderMonkey) engine 🔥. So, the code execution must be delegated to some sort of host machine. 

The simplest case is running the notebooks on the local machine, but this would assume that the user has some sort of environment set up to run Jupyter Notebooks ready to go. This is a no-go, because what guarantee there is that somebody will download a random code from a random blog post and run it on their machine? Slim to none. Additionally, if there is some supplementary data used by the notebook kept in a separate file, the user must download it as well. This is also a hassle and a potential security risk.

It would be a good idea to store all necessary files in a remote location and let the user execute it in a fully sandboxed environment. One possibility would be to spin up a [JupyterLab] instance on a dedicated server and let the user interact with it via a web browser. This is a good idea, but it requires a lot of setup and maintenance, which is not ideal. Also, money. This solution would require renting some sort of infrastructure or using open-source solutions like JupyterHub to orchestrate this process on my own bare metal at home. Either way, I would have to invest in some sort of machine - a physical or virtual one. I won't even delve into the topic of security and managing cloud infrastructure (e.g. K8s cluster), because come on - it is a blog, not a startup 🤦‍♂️.

Here comes [JupyterLite]. It is a stripped-down version of JupyterLab, that can be run in the browser using kernels (from the documentation: *language-specific processes that run independently*) that consume resources and run the code on the client side but via the browser engine. Moreover, it is 100% possible to embed a JupyterLite instance via a simple `iFrame` element, so it is a perfect candidate for a blog post embed.

<CodeSnippet
  code={`
    <iframe
      src="https://jupyterlite.github.io/demo/lab/index.html"
      width="100%"
      height="500px"
    />
  `}
  language="html"
  filename="jupyterlite.html"
/>

So what's up with that URL inside the `iframe` definition? If You visit it manually, it leads to a **JupyterLite instance hosted by the project authors** (here via GitHub Pages). JupyterLite serves statically-generated HTML pages that include bundled initialization scripts, which load prebuilt ports of Jupyter kernels like Pyodide (for Python) or one using Javascript Web Worker. 

These worker processes can only utilize resources of the client machine available to the browser itself (like RAM memory), without connecting to the private storage of the user. This allows for isolation of the code execution process, so it is safe to run arbitrary code in the browser (even when the code wants to allocate too many resources, the kernel will be stopped thanks to the JupyterLab OOM killer).

{false && <iframe
  src="https://jupyterlite.github.io/demo/lab/index.html"
  width="100%"
  height="500px"
  style={{
    marginTop: '1rem',
    marginBottom: '1rem',
  }}
/>}

You can see that it is possible to create new notebooks, interact with existing ones and set up a project directory containing additional assets. JupyterLite also allows for interaction with its kernels via dedicated CLIs (the "Consoles" section on the homepage). So a full-blown IDE inside Your browser 🤯

JupyterLite project allows You to modify and extend Your own deployments of this environment if You want, for example, to include kernels for other languages. This also allows to modify the source code (which will become useful in a second) and theme it according to Your needs. So I want to use the same method but with my version of JupyterLite, like so:

<CodeSnippet
  code={`
    <SomethingThatWrapsMyIFrame>
      <iframe
        src={myJupyterLiteInstanceURL}
        width="100%"
        height="500px"
      />
    </SomethingThatWrapsMyIFrame>
  `}
  language="html"
  filename="custom_jupyterlite.html"
  annotations={`
    1:This wrapper will handle loading state etc.
    5:Ideally I want this to also be a parameter
  `}
/>

The `SomethingThatWrapsMyIFrame` will be used to allow the user to turn on the embedded instance **on demand** via a call to action (a button), wait for the notebook to be rendered (because it might take some time for larger ones) and then display everything in a ready state.

So, the first ingredient 👨‍🍳 - custom JupyterLite deployment. For this purpose, I've followed the JupyterLite documentation on [configuration files] and [extra content].
I've modified my website repo to accommodate source-specific JupyterLite to establish a monorepo that keeps everything in one place.

<FileTree
  root="kamilrybacki.github.io"
  tree={[
    "...",
    {
      "jupyterlite/": [
        "patch.py",
        "jupyter-lite.json",
        "overrides.json",
        "requirements.txt",
        "runtime.txt",
        { "extensions/": [] },
        { "patches/": [] },
      ]
    },
    "...",
    { "src/": [
      "...",
      { "content": [
        "...",
        { "_jupyter/": [] },
        "...",
      ]},
      "..."
    ]}
  ]}
  annotations={`
    jupyterlite:Directory where all JL custom source is kept and the project is built
    patch.py:Python script that patches the JL source code after it is built
    jupyter-lite.json:Main JL configuration file that defines the project
    overrides.json:JL configuration file that overrides the default configuration of various extensions
    requirements.txt:Python dependencies for the JL project (additional libraries for the user)
    runtime.txt:Python runtime version (for building the project)
    src/content/_jupyter:Directory where all additional content is kept (e.g. notebooks)
  `}
/>

Next, I've set up a basic deployment on Vercel that observes a separate `jupyterlite` branch for any changes, which happen when the project is built via CI/CD pipeline at the GitHub repo. So, let's say that we update `branch-1` with the while site's source code. If there are any changes made either to the `jupyterlite` directory or / and my site theme (because themes of both elements **must** 💂 match), GitHub will run the workflow defined in the [`build-jupyterlite.yaml`] manifest. The one exception is when any pull request is merged - the built will also happen automatically.

<CodeSnippet
  code={`
  name: Build Jupyterlite and push it to build branch
  on:
    push:
      paths:
        - jupyterlite/**
        - tailwind.config.js
    pull_request:
      types: [closed]

  jobs:
    build:
      runs-on: ubuntu-latest
      name: Build and push Jupyterlite
      env:
        BUILD_BRANCH: jupyterlite
        BUILD_DIRECTORY: jupyterlite
        BUILD_OUTPUT_DIRECTORY: public
      steps:
        - name: git-checkout
          uses: actions/checkout@v3
        
        - name: Setup Python
          uses: actions/setup-python@v4
          with:
            python-version: '3.10'

        - name: Build Jupyterlite with custom extensions
          env:
            PATCHES_DIRECTORY: patches
            TARGET_DIRECTORY: \${{ env.BUILD_OUTPUT_DIRECTORY }}
          working-directory: \${{ env.BUILD_DIRECTORY }}
          run: |
            ## Install dependencies for Jupyterlite and Jupyterlab
            python -m pip install -r requirements.txt

            ## Copy content (notebooks, images, etc.)
            mkdir ./files
            cp -r ../src/content/_jupyter/* ./files

            ## Install extensions
            cd extensions/
            for EXTENSION in $(ls -d */); do
              cd $EXTENSION
              jlpm cache clean
              pip install -v .
              jlpm run build
              cd ../
            done
            jupyter labextension list

            ## Build Jupyterlite
            cd ../
            jupyter lite build --output-dir \${{ env.BUILD_OUTPUT_DIRECTORY }}

            ## Patch the build
            python patch.py

        - name: Push
          uses: s0/git-publish-subdir-action@develop
          env:
            REPO: self
            BRANCH: \${{ env.BUILD_BRANCH }}
            FOLDER: \${{ env.BUILD_DIRECTORY }}/\${{ env.BUILD_OUTPUT_DIRECTORY }}
            GITHUB_TOKEN: \${{ secrets.GITHUB_TOKEN }}
            MESSAGE: "Build: ({sha}) {msg}"
            TARGET_DIR: public
  `}
  language="yaml"
  filename="build-jupyterlite.yaml"
  annotations={`
    42-49:Build custom JupyterLite extensions
    56:Modify in-place bundled JupyterLite files
    58-66:Push the build to a separate branch
  `}
/>

This allows for easy separation of my JupyterLite source and distribution from my personal webpage code. Additionally, I can experiment on the "live organism" 🦠 by manually modifying stuff at the `jupyterlite` branch and serving it locally (e.g. via `browser-sync`).

##### Boxing the sandbox

As You could see, when You straight up embed JupyterLite deployment on a website, You get the whole "Lab" experience, with the file browser, dozens of options and so on. And here is the controversial part - I don't like it. I want to be a more "atomic" experience, meaning that if I showcase a specific notebook (or code in general), the attention must be focused on it, to prevent the user from either getting lost, distracted, overwhelmed or prone to some kind of error that will ruin the execution of the code. The sandbox without boundaries is a caricature 💩 desert. And You can still get lost in it.

There is an answer to that problem - `RetroLab`, a version of JupyterLab that resembles the old way in which Jupyter notebooks were served. It is a stripped-down version of JupyterLab, that only shows the notebook itself, without any additional options.

{
  false && <iframe
  src="https://jupyterlite.github.io/demo/retro/notebooks/?path=javascript.ipynb"
  width="100%"
  height="500px"
  style={{
    marginTop: '1rem',
    marginBottom: '1rem',
  }}
/>
}

So we are getting pretty close. What I want to do is to disable **completely** the top portion of the frame i.e. header bar and the main menu bar (with the "File", "Edit" and other options). Then I also want to remove some of the notebook toolbar buttons - mainly those that are connected with changing the notebook's layout or execution.

![The plan](/assets/images/jupyterlite_plan.jpg)

After some digging, I've noticed that after building JupyterLite, the whole distribution is separated into apps (basically different routes) that can be used by the user. So normally there would be (among many other directories) a folder named `retro`, which contained this stripped-down version of JL. There were also other directories, that housed other "versions" the user could use e.g. `lab` (the full IDE one) or `repl` (the read-eval-print loop). So, first of all, I've deleted every other app except RetroLab. If You try to access those routes on my Vercel deployment, You will get a 404 error ❌.

Next, inside this `retro` directory, there was a `notebooks` one, that contains a HTML file that is used to display chosen notebooks.

<CodeSnippet
  code={`
    <!DOCTYPE html>
    <html>
      <head>
        <title>JupyterLite Retro - Notebook</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link
          id="jupyter-lite-main"
          rel="preload"
          href="../../build/retro/bundle.js?_=25fc58d"
          main="index"
          as="script"
        />
        <script
          id="jupyter-config-data"
          type="application/json"
          data-jupyter-lite-root="../.."
        >
          {}
        </script>
        <script>
          (async function () {
            const { pathname, origin, search, hash } = window.location;
            if (pathname.match(/(index.html|\/)\$/) == null) {
              window.location.href = \`\${origin}\${pathname}/\${search}\${hash}\`;
              return;
            }

            await import(
              '../../config-utils.js?_=25fc58d'
            );
          })();
        </script>
      </head>
      <body data-retro="notebooks"></body>
    </html> 
  `}
  language="html"
  filename="index.html"
/>

Do You see that `import` in the last `script` tag 👀? That's our way in 🏃‍♀️. Basically, it loads a `config-utils.js` file that is responsible for loading the whole RetroLab app. So, I've extended this to now load three separate scripts: `pre.js`, `main.js` and `post.js`. 

<CodeSnippet
  code={`
    ...
    <script>
      (async function () {
        const { pathname, origin, search, hash } = window.location;
        if (pathname.match(/(index.html|\/)\$/) == null) {
          window.location.href = \`\${origin}\${pathname}/\${search}\${hash}\`;
          return;
        }
        const preScript = await import('../../pre.js').then((m) => m.default);
        const mainScript = await import('../../main.js').then((m) => m.default);
        const postScript = await import('../../post.js').then((m) => m.default);

        await preScript();
        await mainScript();
        await postScript();
      })();
    </script>
    ...
  `}
  language="html"
  filename="index.html (after modification)"
/>

The `main.js` is simply the renamed `config-utils.js`. The `pre.js` and `post.js` are my own scripts that are loaded before and after the `main.js` respectively. The `pre.js`, as of right now, is not used, but I've set it up for the future. The main hero here is the `post.js` script. It waits for the HTML elements of Jupyter notebook are
rendered and hydrated with content to then morph them into the desired shape. To achieve this timed behaviour, a `waitForElementToExist` method is used, that employs
a `MutationObserver` to watch for the changes being made in the DOM. When the desired element is found, the observer is disconnected and the element is returned.

<CodeSnippet
  code={`
    function waitForElementToExist(selector) {
      return new Promise(resolve => {
        if (document.querySelector(selector)) {
          return resolve(document.querySelector(selector));
        }

        const observer = new MutationObserver(() => {
          if (document.querySelector(selector)) {
            resolve(document.querySelector(selector));
            observer.disconnect();
          }
        });

        observer.observe(document.body, {
          subtree: true,
          childList: true,
        });
      });
    }
  `}
  language="js"
  filename="post.js (DOM observer)"
/>

A short research of rendered HTML pages revealed that the elements I want to remove are: `#top-panel-wrapper` and `#menu-panel-wrapper`.
This however left a nasty gap at the top of the page, that was resilient to modifications via `style` attribute or even brute-force deletion.
But, when life gives You lemons, You make lemonade 🍋. I've decided to use this gap to overlay a small help section (in the `.astro` component), 
that will guide the user through the process of using the notebook (and let me credit the amazing JupyterLite authors!).

![JupyterLite help section](/assets/images/retrolab_help.png)

In the same script, I've also changed the values of CSS variables used internally by JupyterLite to change the look of the notebook. Their names
were also easy to find by studying the generated markup using the browser's dev tools.

<CodeSnippet
  code={`
      async function applyBaseSiteTheme() {
        import('./theme.js')
          .then((m) => m.theme)
          .then(({ colors }) => {
            const rootElement = document.querySelector(":root");
            rootElement.style.setProperty('--jp-layout-color2', colors.background);
            rootElement.style.setProperty('--jp-layout-color0', colors.background);
            rootElement.style.setProperty('--jp-toolbar-background', colors.background);
            rootElement.style.setProperty('--jp-ui-font-color1', colors.foreground);
            rootElement.style.setProperty('--jp-content-font-color0', colors.foreground);
            rootElement.style.setProperty('--jp-content-font-color1', colors.foreground);
            rootElement.style.setProperty('--jp-cell-editor-background', colors.background);
            rootElement.style.setProperty('--jp-cell-editor-border-color', colors.foreground);
            rootElement.style.setProperty('--jp-cell-editor-active-border-color', colors.foreground);
            rootElement.style.setProperty('--jp-private-title-panel-height', '0px');
          });
      };
  `}
  language="js"
  filename="post.js (theming)"
  annotations={`
    2:This file is basically a copy of Tailwind config, thrown into JL directory
    5:All of the variables are defined in the root element
  `}
/>

The last thing left is the removal of the chosen menu options, which is done solely through JupyterLite
config JSON files. The `overrides.json` file is used to override the default configuration of
various extensions. There is an extension dedicated to setting up the notebook toolbar, so it was
a matter of finding the right configuration option and setting it to `false`. There are also some
settings being changed, but they are standard options that can be read about in the JupyterLab
documentation, without performing some sort of reverse-engineering. I highly recommend checking
the rest of this configuration on my repo, because it is a bit too long to include it here.
In a very similar way, the per-cell menu bar (normally located in the upper-right part of the cell)
was removed.

<CodeSnippet
  code={`
  {
    ...
    "@jupyterlab/notebook-extension:panel": {
      "toolbar": [
        { "name": "save", "disabled": true },
        { "name": "insert", "disabled": true},
        { "name": "cut", "disabled": true},
        { "name": "copy", "disabled": true },
        { "name": "paste", "disabled": true },
        { "name": "kernelName", "disabled": true },
        { "name": "cellType", "disabled": true },
        {
          "name": "clear-all-outputs",
          "command": "notebook:clear-all-cell-outputs",
          "label": "Clear outputs"
        }
      ]
    }
    ...
  }
  `}
  language="json"
  filename="overrides.json (notebook toolbar)"
/>

I knew what to modify, but there was one last obstruction to applying those modifications.
The JupyterLite build process compiles the actual JupyterLite app from the library source code
(mainly the `jupyterlite-core` package), so modifications had to be made **after** the build.
And "by had to be", I mean I was too lazy to fork the project and carry out my work there, so I
decided to monkey-patch the bundled distribution 🤷‍♀️.

So, I've created a Python script that modifies the built files in place by applying atomic patches
located under `jupyterlite/patches` directory. The script is run as a part of the CI/CD pipeline
and uses `operations.json` file that describes each operation i.e. which file to modify and what
to do with it. The script is pretty straightforward, so I won't include it here, but [You can
check it out on my repo]. This monkey-patched version is then pushed to the `jupyterlite` branch
and deployed via Vercel, finishing the whole process 🥲. Below, You can see the final result of
this endeavor (the greyed-out portion is done differently, as mentioned above).

<iframe
  src="https://myjupyterlite-git-jupyterlite-kamilrybacki.vercel.app/retro/notebooks/?path=lorenz%2FLorenz.ipynb"
  width="100%"
  height="500px"
  style={{
    marginTop: '1rem',
    marginBottom: '1rem',
  }}
/>

##### Unboxing the boxed sandbox 😵

Imagine having a dozen of those notebooks embedded on a single page. It would be a nightmare to
load for people with slower connections. So, I've decided to load them on demand, when the user
clicks on a button. This is done by using a `JupyterLiteEmbed` component, that is basically an
implementation of `<SomethingThatWrapsMyIFrame>` from the previous section.

The plan is simple: user clicks a button, the component state is updated to `loading`, the spinner starts spinnin' 🌀,
the `iframe` with the JupyterLite instance is rendered under the hood (but not displayed), JupyterLite
populates all code cells with content, notifies the component that it is ready, the component hides the spinner,
displays the `iframe` and the notebook is ready to be used.

Out of all of these steps, the notification part is hard to do, because there is no way to
directly access the `iframe`'s content from the parent component. If You try to do it, You will
get a `DOMException` 🚩 that stems from trying to access a cross-origin frame, because it
is loaded from a different origin than the parent component (my Vercel deployment). This is a security feature of the browser,
that prevents malicious code from accessing the content of the `iframe` and potentially stealing sensitive data.

But luckily, there is a standardized way of communicating between the parent and the child from a different origin - the 
`postMessage` API. It allows for sending messages between the two parties, but it is up to the developer
to implement the logic of sending and receiving messages. So, I can just plop it down in the `post.js` script
and send a message to the parent when the notebook is ready, right? Well, here comes a hidden trap of JupyterLite.
If You query the DOM (on the JL's side) for the notebook content to see if it is ready e.g. by checking if the
children of its container are present, You will get a "truthy" response. The elements exist, but they are empty.
However, checking if they contain meaningful content is quite cumbersome. So, I've decided to use a different
approach. I've cooked up a small [JupyterLab extension] and added it to the build assets in the `extensions` directory.

<CodeSnippet
  code={`
    import {
      JupyterFrontEnd,
      JupyterFrontEndPlugin
    } from '@jupyterlab/application';

    /**
    * Initialization data for the notebook-content-load-notify extension.
    */
    const plugin: JupyterFrontEndPlugin<void> = {
      id: 'notebook-content-load-notify:plugin',
      description: 'An extension that notifies the IFrame host that notebook content has loaded',
      autoStart: true,
      activate: (app: JupyterFrontEnd) => {
        console.log('JupyterLab extension notebook-content-load-notify is activated!');

        const notifyNotebookContentLoaded = (): void => {
          const message = { type: 'from-iframe-to-host', notebookContentLoaded: true };
          window.parent.postMessage(message, '*');
        }

        app.serviceManager.sessions.runningChanged
          .connect(() => {
            const notebookContentLoaded = document.querySelector('.jp-NotebookPanel') !== null;
            if (notebookContentLoaded) {
              notifyNotebookContentLoaded();
          }
          });
      }
    };
    export default plugin;
  `}
  language="ts"
  filename="notebook-content-load-notify"
  annotations={`
    1-4:Import JupyterLab interfaces for interacting with frontend
    10-12:Define the plugin
    16-19:If the notebook is ready, send a message to the parent
    21-28:Listen for the notebook to be ready by hooking to the session manager
  `}
/>

This is a small part of the boilerplate mini-project located in the aforementioned directory, so
there are some caveats to successfully building it. One unintuitive thing is to include a `yarn.lock`
file inside the extension root directory if it is a part of a larger repo (like mine) because `jupyter` CLI
will try to install dependencies from the root directory, not the extension one. Also, I had to do
a light version mangling of some dependencies in `package.json` to make it work with both `jupyterlite`.

<CodeSnippet
  code={`
    ...
    "dependencies": {
      "@jupyterlab/application": "^3.5.3 || ^4.0.7",
      "@jupyterlab/apputils": "^3.5.3 || ^4.0.7"
    },
    "devDependencies": {
      "@jupyterlab/builder": "^3.5.3 || ^4.0.7",
    }
  `}
  language="json"
  filename="package.json (extension)"
/>

After building JupyterLite with this custom extension and deploying it to Vercel, I've started working on
the wrapper component. It is a simple state machine that is responsible for displaying the correct content
at the correct time. It is also responsible for displaying the help section, shown previously. The most important part of its state management in the context
of this article is an additional `EventListener` added to the `window` object, that listens for the message sent by the extension. When the message is received,
the component state is updated to `ready` and the spinner is hidden.

<CodeSnippet
  code={`
    ...
    React.useEffect(() => {
      if (startNotebook) {
        iframeWrapperRef.current!.style.height = convertCssUnit(size) + "px";
        loadingSpinnerRef.current!.style.height = convertCssUnit(size) + "px";
        jupyterIFrameRef.current!.style.height = convertCssUnit(size) + "px";
        window.addEventListener("message", ({ data }) => {
          if (data.notebookContentLoaded && !isLoaded) {
            setIsLoaded(true);
          }
        });
        loadingSpinnerRef.current!.classList.replace("hidden", "flex");
        loadingSpinnerRef.current!.classList.add("flex-col");
        if (!isLoaded) {
          setTimeout(() => {
            setLoadingText(["Still loading notebook..."]);
            setTimeout(() => {
              setLoadingText(["Still loading notebook...", "(maybe come back here in a while)"]);
            }, loadingTimeout);
          }, loadingTimeout);
        }
      }
    }, [startNotebook]);
    ...
  `}
  language="tsx"
  filename="JupyterLiteEmbed.tsx (useEffect)"
  annotations={`
    4-6:Prepares the heights of the elements
    7-10:Listens for the message sent by IFrame
    12-13:Shows the spinner
    14-22:Adds timeouts to show a changing loading text
    23:This state is updated by button click
  `}
/>

The last thing left is to add a button that will trigger the loading process and theme everything around our embedded notebook, so it looks nice and clean.
Here is the final result:

import JupyterLiteEmbed from "@components/markdown/JupyterLiteEmbed"

<JupyterLiteEmbed
  size="500px"
  file="lorenz/Lorenz.ipynb"
  kernel="python"
  client:load
/>

You can see it's consistent with the site theme, You can do crazy stuff like
write awful Python code and print "Hello World" `n` amount of times, where `n` is a random number between 1 and 1000 (provided via `random` library 🐍). There is also a possibility to include richly formatted descriptions 🖋️ for the subsequent code cells, so the user can understand what is going on (**using Markdown**). And **no extra data** is required by the user, it is all bundled into JupyterLite deployment. An isolated sandbox for the guided presentation of live code.

![YEAH BOOOOI](/assets/images/awesome.png)

#### What's in the bounding box? 🔫📦 - `CodePenEmbed` component

Okay, so we have a way of embedding Jupyter notebooks, but what about other code? I've decided to use [CodePen] for this purpose, because it is a very popular tool for sharing code snippets among front end developers. It is also very easy to use, because it allows for embedding a pen via a simple `iframe` element and a complimentary script, easily available on the `unpkg` CDN. So, I've created a wrapper component that is responsible for loading the pen and displaying it when it is ready, similarly to the `JupyterLiteEmbed` component.

CodePen provides a totally awesome API that allows You to create pre-filled embeds programmatically, by setting appropriate `dataset` attributes of the container `iframe` element.

<CodeSnippet
  code={`
      <div 
        class="codepen" 
        data-prefill='{
          "title": "React Basics Demo",
          "description": "Shows how to use React and React DOM to render a module with props onto the page",
          "tags": ["react", "react-docs-demo"],
          "html_classes": ["loading", "no-js"],
        }'
        style="height: 400px; overflow: auto;"
        data-height="400" 
        data-theme-id="31205"
        data-default-tab="js,result" 
        data-editable="true"     
      >
        <pre data-lang="html">
          &lt;div id="root"&gt;&lt;/div&gt;
        </pre>
        <pre data-lang="scss">
          $gray: #ccc;
          body {
            background: $gray;
            margin: 0;
            padding: 1rem;
          }
        </pre>
        <pre data-lang="babel">
          class Welcome extends React.Component {
            render() {
              return &lt;div class="module"&gt;
                &lt;h1&gt;
                  Hello, {this.props.name}
                &lt;/h1&gt;
                &lt;p&gt;It's a good day to build websites.&lt;/p&gt;
              &lt;/div&gt;;
            }
          }
          ReactDOM.render(
            &lt;Welcome name="Chris"&gt;&lt;/Welcome&gt;,
            document.getElementById('root')
          );
        </pre>
      </div>
  `}
  language="html"
  filename="CodePen embed"
/>

So, You can see that each tab of the CodePen embedded sandbox corresponds to a `pre` tag with `data-lang` property set to the type of code contained within it.
I've decided to abstract it into properties of a new Astro component, that will have a couple of tricks up its sleeve 🎩🐇.

The on-demand loading is simply carried by the `__CPEmbed` function that loads the pen into a HTML Element specified by a DOM selector. The function is called
when the call to action button is pressed and voila! The pen is loaded. So what is the other trick? **Console capturing**.

See, when any `console` interface call is made inside the input code, it is displayed in the browser's console. Imagine combing through the output of the whole page (and in the case of my blog the console gets dirty pretty quickly 🐷) to see if the demonstrated code spits out the correct coordinates of Your cursor when it is being moved over some random `div` element in the "Preview" tab. I've added a "Console output" container that displays those messages, below the pen itself.

This was done by using the `__codePenIFrameAddedToPage` hook, automatically added to the host `window` element by the `ei.js` script (the extra source mentioned earlier and described in the API documentation). As the name suggests, when the `iframe` with the pen is loaded, the hook adds a new `EventListener` that functions in the same way as the one in the `JupyterLiteEmbed` component. The message that it listens for is sent via a script injected into either HTML or JS source code of the pen. This payload contains the ID of the sender (the pen) and the log text itself. If the message comes to the Astro component (`CodePenEmbed`) from its descendant (not some other random pen at the beginning of the page) is then appended as a new `span` element to the "Console output" container.

<CodeSnippet
  code={`
    ...
    window.__CodePenIFrameAddedToPage = () => {
      window.addEventListener('message', function(event){
        if (event.data.from !== codepenId) return;
        const currentTime = new Date()
          .toISOString()
          .replace(/T/, ' ')
          .replace(/\..+/, '');
        if (consoleElement.innerHTML === '') {
          consoleElement.innerHTML = \`[\${currentTime}] \${event.data.message}\`;
        }
        else consoleElement.innerHTML += \`<br>[\${currentTime}] \${event.data.message}\`
      }, false);
    }
    ...
  `}
  language="js"
  filename="CodePenEmbed.astro (capturing)"
  annotations={`
    3:Don't listen to strangers (pens from other components)
    4-7:Pretty-print the timestamp
    11:Here, newlines are appended manually
  `}
/>

And that's really it 🤷‍♀️. The rest is just a matter of styling the component to fit the theme of the website, which is done (as You've probably guessed like a hundred paragraphs ago) by shoving TailwindCSS classes into random elements until everything sticks together 👍. Anyway, here's the magic manifested.

<CodePenEmbed
  blocks={{
    "html": `
      <div>
        <h1>Hello World</h1>
        <p>lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat</p>
      </div>
    `,
    "css": `
      p { color: red; }
    `,
    "js": `
      for (let i = 0; i < 100; i++) {
        console.log(i);
      }
    `
  }}
  options={{
    "themeId": "dark",
    "editable": true,
    "height": "500",
    "defaultTab": "html,result"
  }}
  size={500}
  title="Test"
  description="Test CodePenEmbed"
  tags={["cool"]}
/>

### Show me the numbers 📊 - `ScribbleGraph` component

I like hand-drawn figures, illustrations, diagrams and other serious hieroglyphics that are thrown around in the technical world. There is a soothing juxtaposition of formal and informal. Like, even if the stuff on those diagrams is totally from another planet, those squiggly lines and slightly skewed shapes can fill You with a false sense of security 😌 - everything is made by humans for humans. If a human mind has crafted it, a human mind can digest it. And then You encounter cryptid-level monstrosities like [iron-carbon phase diagram] during Your undergrad studies on material engineering and even the hand-drawn version throws Your heart into the void.

But in data science, the graphs are often cool and interesting, they draw You in with their content, so additional styling is only the cherry on top 🍒. For this goal, I've chosen the `rough-viz` JavaScript library and implemented a wrapper component (another one!) that adds stuff like a stylized title, caption and axis labels. Its main job is to apply the theme after `rough-viz` finishes initializing its graph element, because it is done via a constructor, that, when fired up, latches onto a selected `div` by its ID. There is on caveat during application of the colors - the `rough-viz` graphs are normally created in "light mode", so colored data lines with **black axis lines**. But, if I first invert the colors of the lines, create the graph and then invert **the colors of the whole graph**, I get the desired effect - my theme colors set for the data series and white axis lines 🎨📈.

<CodeSnippet
  code={`
    ...
    React.useEffect(() => {
      if (!graph) {
        if (color || stroke) {
          console.warn(
            \`You should not specify color or stroke in the options for \${title} because they are set by the theme.\`,
          );
        }
        const graphPrototype = graphTypeMap[type];
        // @ts-ignore
        const newGraph = new graphPrototype({
          element: \`#\${graphContainerId}\`,
          data: data,
          ...rest,
          stroke: invert(theme.colors.glow),
          color: invert(theme.colors.glow),
          colors: rest.colors ? rest.colors.map((currentColor: string) => invert(currentColor)) : [],
          titleFontSize: "1.5rem",
          margin: { top: 0, right: 0, bottom: 25, left: 25 },
        });
        setGraph(newGraph);
        if (!window.localStorage.getItem("lastGraphId")) {
          window.localStorage.setItem("lastGraphId", "1");
        } else {
          setGraphCounter(parseInt(window.localStorage.getItem("lastGraphId") || "1") + 1);
        }
      }
    }, [data, options]);
    ...
  `}
  language="tsx"
  filename="ScribbleGraph.tsx (useEffect)"
  annotations={`
    6:Yeah, its hardcoded via site theme
    11-19:Here is that constructor that hydrates a container
    21:Here I notify the component that graph is rendered
    22-26:Automatic ordering
  `}
/>

No other complex state management is done, because the library is pretty straightforward to use. A little nugget of magic is planted in the form of an automatic figure number counter, so the ordering of new graphs is carried out on the scope of the viewed page on its own. Check out the final result below.

import ScribbleGraph from "@components/markdown/ScribbleGraph"

<ScribbleGraph
  type="scatter"
  data={{
    x: [1, 2, 3, 4],
    y: [10, 15, 13, 17],
  }}
  height={300}
  title="Test"
  caption="Test"
  options={{}}
  width={500}
  client:load
/>

## Geared up and ready to roll 🛠️

I really hope that this presentation of more and more complicated concepts with gradually evolving "helping hands" in the form of my custom components planted this crazy idea in Your head 🪴 to use more visual and interactive measures of showing off catchy ideas in a more digestible manner. Also, I guess there is some practical knowledge about e.g. how `iframe`s can communicate with their host "embedder" or how to chisel out Your cool modifications in the JupyterLite monolith via kind-of code injection or actual Jupyterlab extensions. With these gadgets, I tend to present my technological ramblings unbound by the limitations of spoken word. Prepare to be amazed, I guess 🤷‍♀️.

![tada](/assets/images/office_magic.gif)

[knowledge]: https://tenor.com/pl/view/knowledge-tai-lopez-lamborghini-gif-19251888
[GitHub Octokit]: https://github.com/octokit
[source]: https://raw.githubusercontent.com/kamilrybacki/kamilrybacki.github.io/main/src/components/markdown/FileTree.astro
[logo]: https://user-images.githubusercontent.com/139819/199528006-bc534966-4aee-45da-8d1e-0e71b97a56b3.png
[`shiki` library docs on how to load them]: https://github.com/shikijs/shiki/blob/main/docs/themes.md
[JupyterLab]: https://github.com/jupyterlab/jupyterlab
[JupyterHub]: https://github.com/jupyterhub/jupyterhub
[JupyterLite]: https://github.com/jupyterlite
[configuration files]: https://jupyterlite.readthedocs.io/en/stable/howto/configure/config_files.html
[extra content]: https://jupyterlite.readthedocs.io/en/stable/howto/content/files.html#
[`build-jupyterlite.yaml`]: https://github.com/kamilrybacki/kamilrybacki.github.io/blob/main/.github/workflows/build-jupyterlite.yaml
[You can check it out on my repo]: https://github.com/kamilrybacki/kamilrybacki.github.io/blob/main/jupyterlite/patch.py
[JupyterLab extension]: https://jupyterlab.readthedocs.io/en/stable/user/extensions.html
[CodePen]: https://blog.codepen.io/documentation/embedded-pens/
[Iron-Carbon phase diagram]: https://fractory.com/iron-carbon-phase-diagram/
